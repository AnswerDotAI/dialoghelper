# tracetools


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` python
from IPython.display import display,Markdown
import textwrap
```

[`tracetool`](https://AnswerDotAI.github.io/dialoghelper/tracetools.html#tracetool)
is an LLM tool that traces function execution and captures variable
snapshots after each line runs, using Python 3.12â€™s `sys.monitoring` for
low-overhead tracing.

For each call to the target function (including recursive calls), the
LLM receives a stack trace showing how that call was reached, plus a
per-line trace dict mapping each executed source line to its hit count
and variable snapshots. Variables that donâ€™t change are shown as a
single `(type, repr)` tuple, while those that evolve across iterations
appear as a list of snapshots.

This is particularly useful when the LLM needs to understand unfamiliar
code by seeing exactly what happens step-by-step, debug issues by
watching how variables change, verify loop behavior by confirming
iteration counts and accumulator values, or explore recursive functions
where each call gets its own trace entry.

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/dialoghelper/blob/main/dialoghelper/tracetools.py#L22"
target="_blank" style="float:right; font-size:smaller">source</a>

### tracetool

``` python

def tracetool(
    sym:str, # Dotted symbol path of callable to run
    args:list=None, # Positional args for callable (JSON values passed directly)
    kwargs:dict=None, # Keyword args for callable (JSON values passed directly)
    target_func:str=None, # Dotted symbol path of function to trace (defaults to sym)
)->list: # List of (stack_str,trace_dict); trace_dict maps source snippets to (hit_count, variables), unchanged vars collapsed to single tuple

```

*Trace execution using sys.monitoring (Python 3.12+), returning a list
of per-call traces.*

Return: - list of length \<= 10 - one element per call to `target_func`
(including recursion) - each element is: (stack_str, trace_dict)
stack_str: call stack string (filtered so `fn` is the shallowest frame
shown) trace_dict: { â€œ<source snippet for AST-line>â€: ( hit_count, {
â€œvarâ€: \[ (type_name, truncated_repr), â€¦ up to 10 \], â€¦ } ), â€¦}

Semantics: - â€œLineâ€ means an AST-level line: separate statements (even
if on one physical line via `;`). - Compound statements are keyed by
their header only. - Unchanged variables â†’ `('type', 'repr')` tuple,
changed variables â†’ `[('type', 'repr'), ...]` list. - Comprehensions are
treated as a line node and are monitored, including inside the
comprehension frame, with per-iteration snapshots. - Snapshots are
recorded after each line finishes, so assignments show updated values.

``` python
def demo(n,m='x'):
    total = 0
    for i in range(n): total += i
    return m*total
```

Try using
&[`tracetool`](https://AnswerDotAI.github.io/dialoghelper/tracetools.html#tracetool)
to trace `demo(5, m='y')`. Based on the results, tell me how `demo`
works.

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

<details class="tool-usage-details">

<summary>

tracetool(sym=demo, args=\[5\], kwargs={â€˜mâ€™: â€˜yâ€™})
</summary>

``` json
{
  "id": "toolu_01CeHDU3L8nuEZZL6xCnRpE4",
  "call": {
    "function": "tracetool",
    "arguments": {
      "sym": "demo",
      "args": "[5]",
      "kwargs": "{'m': 'y'}"
    }
  },
  "result": "[('',\n  {'total = 0': (1, {'total': ('int', '0')}),\n   'for i in range(n):': (6,\n    {'i': [('int', '0'),\n      ('int', '1'),\n      ('int', '2'),\n      ('int', '3'),\n      ('int', '4'),\n      ('int', '4')],\n     'n': ('int', '5')}),\n   'total += i': (5,\n    {'i': [('int', '0'),\n      ('int', '1'),\n      ('int', '2'),\n      ('int', '3'),\n      ('int', '4')],\n     'total': [('int', '0'),\n      ('int', '1'),\n      ('int', '3'),\n      ('int', '6'),\n      ('int', '10')]}),\n   'return m*total': (1, {'m': ('str', \"'y'\"), 'total': ('int', '10')})})]"
}
```

</details>

The `demo` function:

1.  **Initializes** `total = 0`
2.  **Loops** through `range(n)` where `n=5`, iterating with `i` from 0
    to 4
3.  **Accumulates** the sum by adding each `i` to `total` (0â†’0, +1â†’1,
    +3â†’3, +6â†’6, +10â†’10)
4.  **Returns** `m * total`, which multiplies the string `'y'` by 10,
    giving `'yyyyyyyyyy'`

So `demo(n, m)` computes the sum of integers from 0 to n-1 (which is
`n*(n-1)/2`), then repeats the string `m` that many times. For
`demo(5, m='y')`, it returns `'y' * 10 = 'yyyyyyyyyy'`.

``` python
def quotefunc(s): return textwrap.wrap('aaa '*10, width=10, subsequent_indent='> ')
tests = 'aaa '*10
quotefunc(tests)
```

    ['aaa aaa', '> aaa aaa', '> aaa aaa', '> aaa aaa', '> aaa aaa']

Try tracing `textwrap.TextWrapper._wrap_chunks` by calling quotefunc.

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

<details class="tool-usage-details">

<summary>

tracetool(sym=quotefunc, args=\[â€˜testâ€™\],
target_func=textwrap.TextWrapper.\_wrap_chunks)
</summary>

``` json
{
  "id": "toolu_01KmGXSpBR2CCkrVAXaiu6ty",
  "call": {
    "function": "tracetool",
    "arguments": {
      "sym": "quotefunc",
      "args": "['test']",
      "target_func": "textwrap.TextWrapper._wrap_chunks"
    }
  },
  "result": "[('quotefunc (4125899319.py:2)\\nwrap (/Users/jhoward/.local/share/uv/python/cpython-3.12.8-macos-aarch64-none/lib/python3.12/textwrap.py:384)\\nwrap (/Users/jhoward/.local/share/uv/python/cpython-3.12.8-macos-aarch64-none/lib/python3.12/textwrap.py:359)\\n_wrap_chunks (/Users/jhoward/.local/share/uv/python/cpython-3.12.8-macos-aarch64-none/lib/python3.12/textwrap.py:238)',\n  {'\"\"\"_wrap_chunks(chunks : [string]) -> [string]\\n\\n    Wrap a sequence of text chunks and return a list of lines of\\n    length \\'self.width\\' or less.  (If \\'break_long_words\\' is false,\\n    some lines may be longer than <TRUNCATED>"
}
```

</details>

Fascinating! Hereâ€™s how `_wrap_chunks` works:

**Setup:** - Initializes empty `lines` list, validates width, reverses
`chunks` (so it can pop from the end efficiently)

**Main loop (5 iterations for 5 output lines):** 1. Sets `indent` â€”
empty string for line 1, `'> '` for subsequent lines 2. Calculates
available `width` â€” 10 for line 1, 8 for others (after subtracting
indent length) 3. Inner loop pops chunks onto `cur_line`, tracking
`cur_len`, until adding next chunk would exceed width 4. Strips trailing
whitespace: `['aaa', ' ', 'aaa', ' ']` â†’ `['aaa', ' ', 'aaa']` (cur_len
8â†’7) 5. Joins with indent: `'' + 'aaa aaa'` or `'> ' + 'aaa aaa'`

**Key observations:** - `width` is 10 on first line but 8 thereafter
(due to 2-char `'> '` indent) - Each line gets exactly
`['aaa', ' ', 'aaa']` = 7 chars, fitting within the available width -
The trailing space is always stripped before joining - Never hits
`_handle_long_word` since no chunk exceeds width

------------------------------------------------------------------------

<a
href="https://github.com/AnswerDotAI/dialoghelper/blob/main/dialoghelper/tracetools.py#L52"
target="_blank" style="float:right; font-size:smaller">source</a>

### fmt_trace

``` python

def fmt_trace(
    traces
):

```

*Format tracetool output as markdown*

For a human friendly version, use
[`fmt_trace`](https://AnswerDotAI.github.io/dialoghelper/tracetools.html#fmt_trace)
on the result.

``` python
r = tracetool(sym='quotefunc', args=['test'], target_func='textwrap.TextWrapper._wrap_chunks')
```

``` python
Markdown(fmt_trace(r))
```

**Stack:**

    quotefunc (1868596414.py:1)
    wrap ($PYTHON_STDLIB/textwrap.py:384)
    TextWrapper.wrap ($PYTHON_STDLIB/textwrap.py:359)
    TextWrapper._wrap_chunks ($PYTHON_STDLIB/textwrap.py:238)

<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 24%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr>
<th>Source</th>
<th>Hits</th>
<th>Variables</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lines = []</code></td>
<td>1</td>
<td><code>lines</code>: <code>[]</code></td>
</tr>
<tr>
<td><code>if self.width &lt;= 0:</code></td>
<td>1</td>
<td><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>if self.max_lines is not None:</code></td>
<td>1</td>
<td><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>chunks.reverse()</code></td>
<td>1</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code></td>
</tr>
<tr>
<td><code>while chunks:</code></td>
<td>6</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[' ', 'aaa', ' ', 'aaa']</code> â†’ <code>[]</code></td>
</tr>
<tr>
<td><code>cur_line = []</code></td>
<td>5</td>
<td><code>cur_line</code>: <code>[]</code></td>
</tr>
<tr>
<td><code>cur_len = 0</code></td>
<td>5</td>
<td><code>cur_len</code>: <code>0</code></td>
</tr>
<tr>
<td><code>if lines:</code></td>
<td>5</td>
<td><code>lines</code>: <code>[]</code> â†’ <code>['aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code></td>
</tr>
<tr>
<td><code>indent = self.subsequent_indent</code></td>
<td>4</td>
<td><code>indent</code>: <code>'&gt; '</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>indent = self.initial_indent</code></td>
<td>1</td>
<td><code>indent</code>: <code>''</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>width = self.width - len(indent)</code></td>
<td>5</td>
<td><code>indent</code>: <code>''</code> â†’ <code>'&gt; '</code> â†’
<code>'&gt; '</code> â†’ <code>'&gt; '</code> â†’
<code>'&gt; '</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code><br><code>width</code>:
<code>10</code> â†’ <code>8</code> â†’ <code>8</code> â†’ <code>8</code> â†’
<code>8</code></td>
</tr>
<tr>
<td><code>if self.drop_whitespace and chunks[-1].strip() == '' and lin...</code></td>
<td>5</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[' ', 'aaa', ' ', 'aaa']</code><br><code>lines</code>:
<code>[]</code> â†’ <code>['aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>while chunks:</code></td>
<td>25</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code></td>
</tr>
<tr>
<td><code>l = len(chunks[-1])</code></td>
<td>24</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code><br><code>l</code>:
<code>3</code> â†’ <code>1</code> â†’ <code>3</code> â†’ <code>1</code> â†’
<code>3</code> â†’ <code>3</code> â†’ <code>1</code> â†’ <code>3</code> â†’
<code>1</code> â†’ <code>3</code></td>
</tr>
<tr>
<td><code>if cur_len + l &lt;= width:</code></td>
<td>24</td>
<td><code>cur_len</code>: <code>0</code> â†’ <code>3</code> â†’
<code>4</code> â†’ <code>7</code> â†’ <code>8</code> â†’ <code>0</code> â†’
<code>3</code> â†’ <code>4</code> â†’ <code>7</code> â†’
<code>8</code><br><code>l</code>: <code>3</code> â†’ <code>1</code> â†’
<code>3</code> â†’ <code>1</code> â†’ <code>3</code> â†’ <code>3</code> â†’
<code>1</code> â†’ <code>3</code> â†’ <code>1</code> â†’
<code>3</code><br><code>width</code>: <code>10</code> â†’ <code>10</code>
â†’ <code>10</code> â†’ <code>10</code> â†’ <code>10</code> â†’ <code>8</code> â†’
<code>8</code> â†’ <code>8</code> â†’ <code>8</code> â†’ <code>8</code></td>
</tr>
<tr>
<td><code>cur_line.append(chunks.pop())</code></td>
<td>20</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code><br><code>cur_line</code>:
<code>['aaa']</code> â†’ <code>['aaa', ' ']</code> â†’
<code>['aaa', ' ', 'aaa']</code> â†’ <code>['aaa', ' ', 'aaa', ' ']</code>
â†’ <code>['aaa']</code> â†’ <code>['aaa', ' ']</code> â†’
<code>['aaa', ' ', 'aaa']</code> â†’ <code>['aaa', ' ', 'aaa', ' ']</code>
â†’ <code>['aaa']</code> â†’ <code>['aaa', ' ']</code></td>
</tr>
<tr>
<td><code>cur_len += l</code></td>
<td>20</td>
<td><code>cur_len</code>: <code>3</code> â†’ <code>4</code> â†’
<code>7</code> â†’ <code>8</code> â†’ <code>3</code> â†’ <code>4</code> â†’
<code>7</code> â†’ <code>8</code> â†’ <code>3</code> â†’
<code>4</code><br><code>l</code>: <code>3</code> â†’ <code>1</code> â†’
<code>3</code> â†’ <code>1</code> â†’ <code>3</code> â†’ <code>1</code> â†’
<code>3</code> â†’ <code>1</code> â†’ <code>3</code> â†’ <code>1</code></td>
</tr>
<tr>
<td><code>break</code></td>
<td>4</td>
<td></td>
</tr>
<tr>
<td><code>if chunks and len(chunks[-1]) &gt; width:</code></td>
<td>5</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[]</code><br><code>width</code>: <code>10</code> â†’ <code>8</code>
â†’ <code>8</code> â†’ <code>8</code> â†’ <code>8</code></td>
</tr>
<tr>
<td><code>if self.drop_whitespace and cur_line and cur_line[-1].strip(...</code></td>
<td>5</td>
<td><code>cur_line</code>:
<code>['aaa', ' ', 'aaa', ' ']</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code></td>
</tr>
<tr>
<td><code>cur_len -= len(cur_line[-1])</code></td>
<td>5</td>
<td><code>cur_len</code>: <code>7</code><br><code>cur_line</code>:
<code>['aaa', ' ', 'aaa', ' ']</code></td>
</tr>
<tr>
<td><code>del cur_line[-1]</code></td>
<td>5</td>
<td><code>cur_line</code>: <code>['aaa', ' ', 'aaa']</code></td>
</tr>
<tr>
<td><code>if cur_line:</code></td>
<td>5</td>
<td><code>cur_line</code>: <code>['aaa', ' ', 'aaa']</code></td>
</tr>
<tr>
<td><code>if (self.max_lines is None or</code></td>
<td>5</td>
<td><code>chunks</code>:
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa'...</code> â†’
<code>[' ', 'aaa', ' ', 'aaa', ' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[' ', 'aaa', ' ', 'aaa']</code> â†’
<code>[]</code><br><code>cur_len</code>:
<code>7</code><br><code>lines</code>: <code>[]</code> â†’
<code>['aaa aaa']</code> â†’ <code>['aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code><br><code>self</code>:
<code>&lt;textwrap.TextWrapper object&gt;</code><br><code>width</code>:
<code>10</code> â†’ <code>8</code> â†’ <code>8</code> â†’ <code>8</code> â†’
<code>8</code></td>
</tr>
<tr>
<td><code>lines.append(indent + ''.join(cur_line))</code></td>
<td>5</td>
<td><code>cur_line</code>:
<code>['aaa', ' ', 'aaa']</code><br><code>indent</code>: <code>''</code>
â†’ <code>'&gt; '</code> â†’ <code>'&gt; '</code> â†’ <code>'&gt; '</code> â†’
<code>'&gt; '</code><br><code>lines</code>: <code>['aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code> â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa']</code>
â†’
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aa...</code></td>
</tr>
<tr>
<td><code>return lines</code></td>
<td>1</td>
<td><code>lines</code>:
<code>['aaa aaa', '&gt; aaa aaa', '&gt; aaa aaa', '&gt; aaa aa...</code></td>
</tr>
</tbody>
</table>
